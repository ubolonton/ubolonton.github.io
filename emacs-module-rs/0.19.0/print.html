<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>emacs-module-rs 0.19</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded "><a href="hello.html"><strong aria-hidden="true">1.</strong> Hello, Emacs!</a></li><li class="chapter-item expanded "><a href="module.html"><strong aria-hidden="true">2.</strong> Declaring a Module</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">3.</strong> Writing Functions</a></li><li class="chapter-item expanded "><a href="calling-lisp.html"><strong aria-hidden="true">4.</strong> Calling Lisp Functions</a></li><li class="chapter-item expanded "><a href="type-conversions.html"><strong aria-hidden="true">5.</strong> Type Conversions</a></li><li class="chapter-item expanded "><a href="custom-types.html"><strong aria-hidden="true">6.</strong> Custom Types</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">7.</strong> Error Handling and Signaling</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">8.</strong> Testing</a></li><li class="chapter-item expanded "><a href="reloading.html"><strong aria-hidden="true">9.</strong> Live Reloading</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">emacs-module-rs 0.19</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p><code>emacs-module-rs</code> provides high-level Rust binding and tools to write Emacs's dynamic modules. It is easy to use if you know either Rust or Emacs.</p>
<p>It currently supports:</p>
<ul>
<li>Stable Rust 1.56+.</li>
<li>Emacs 25 or above, built with module support.</li>
<li>macOS, Linux, Windows.</li>
</ul>
<h2 id="setting-up"><a class="header" href="#setting-up">Setting up</a></h2>
<ul>
<li>Install the Rust toolchain with <a href="https://www.rustup.rs/">rustup</a>.</li>
<li>Make sure that your Emacs was compiled with module support. Check that <code>module-file-suffix</code> is not <code>nil</code>, and the function <code>module-load</code> is defined.
<ul>
<li>On macOS, the recommended installation method is MacPorts (<code>emacs-app</code> and <code>emacs-mac-app</code>).</li>
<li>On Windows, the recommended installation method for older Emacs versions (before 27.2) is <code>pacman -S mingw-w64-x86_64-emacs</code> (msys2), as the archives on GNU FTP's server were built without module support.</li>
</ul>
</li>
</ul>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<ul>
<li>On Windows, only Rust's <code>msvc</code> toolchain was confirmed to work, not the <code>gnu</code> toolchain.</li>
<li>When the optional feature <code>bindgen</code> is enabled, the raw binding will be generated from <code>emacs-module.h</code> at build time. Therefore you will also need to install <code>clang</code>. (This is recommended only for troubleshooting, though.) For example, on Windows:
<pre><code class="language-powershell"># In Powershell
scoop install llvm

$env:LIBCLANG_PATH = &quot;$(scoop prefix llvm)\bin&quot;
cargo build --all
</code></pre>
</li>
</ul>
<h2 id="known-issues"><a class="header" href="#known-issues">Known Issues</a></h2>
<p>There is a bug (see <a href="https://github.com/ubolonton/emacs-module-rs/issues/1">issue #1</a>) with Emacs 26 on Linux that prevents it from loading <em>any dynamic modules</em> (even those written in C), if:</p>
<ul>
<li>Emacs is built without thread support.</li>
<li>The OS is Ubuntu 16.04 (Xenial).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-emacs"><a class="header" href="#hello-emacs">Hello, Emacs!</a></h1>
<p>Create a new project:</p>
<pre><code class="language-bash">cargo new greeting
cd greeting
</code></pre>
<p>Modify <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
edition = &quot;2018&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
emacs = &quot;0.19&quot;
</code></pre>
<p>Write code in <code>src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use emacs::{defun, Env, Result, Value};

// Emacs won't load the module without this.
emacs::plugin_is_GPL_compatible!();

// Register the initialization hook that Emacs will call when it loads the module.
#[emacs::module]
fn init(env: &amp;Env) -&gt; Result&lt;Value&lt;'_&gt;&gt; {
    env.message(&quot;Done loading!&quot;)
}

// Define a function callable by Lisp code.
#[defun]
fn say_hello(env: &amp;Env, name: String) -&gt; Result&lt;Value&lt;'_&gt;&gt; {
    env.message(&amp;format!(&quot;Hello, {}!&quot;, name))
}
<span class="boring">}</span></code></pre></pre>
<p>Build the module and create a symlink with <code>.so</code> extension so that Emacs can recognize it:</p>
<pre><code class="language-bash">cargo build
cd target/debug

# If you are on Linux
ln -s libgreeting.so greeting.so

# If you are on macOS
ln -s libgreeting.dylib greeting.so
</code></pre>
<p>Add <code>target/debug</code> to your Emacs's <code>load-path</code>, then load the module:</p>
<pre><code class="language-lisp">(add-to-list 'load-path &quot;/path/to/target/debug&quot;)
(require 'greeting)
(greeting-say-hello &quot;Emacs&quot;)
</code></pre>
<p>The minibuffer should display the message <code>Hello, Emacs!</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declaring-a-module"><a class="header" href="#declaring-a-module">Declaring a Module</a></h1>
<p>Each dynamic module must have an initialization function, marked by the attribute macro <code>#[emacs::module]</code>. The function's type must be <code>fn(&amp;Env) -&gt; Result&lt;()&gt;</code>.</p>
<p>In addition, in order to be loadable by Emacs, the module must be declared GPL-compatible.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>emacs::plugin_is_GPL_compatible!();

#[emacs::module]
fn init(env: &amp;Env) -&gt; Result&lt;()&gt; {
    // This is run when Emacs loads the module.
    // More concretely, it is run after all the functions it defines are exported,
    // but before `(provide 'feature-name)` is (automatically) called.
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<ul>
<li>
<p><code>name</code>: By default, the name of the feature provided by the module is the crate's name (with <code>_</code> replaced by <code>-</code>). There is no need to explicitly call <code>provide</code> inside the initialization function. This option allows the function's name, or a string, to be used instead.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Putting `rs` in crate's name is discouraged so we use the function's name
// instead. The feature will be `rs-module-helper`.
#[emacs::module(name(fn))]
fn rs_module_helper(_: &amp;Env) -&gt; Result&lt;()&gt; { Ok(()) }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><code>defun_prefix</code> and <code>separator</code>: Function names in Emacs are conventionally prefixed with the feature name followed by <code>-</code>. These 2 options allow a different prefix and separator to be used.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use `/` as the separator that goes after feature name, like some other packages.
#[emacs::module(separator = &quot;/&quot;)]
fn init(_: &amp;Env) -&gt; Result&lt;()&gt; { Ok(()) }
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The whole package contains other Lisp files, so the module is named
// `tree-sitter-dyn`. But we want functions to be `tree-sitter-something`,
// not `tree-sitter-dyn-something`.
#[emacs::module(name = &quot;tree-sitter-dyn&quot;, defun_prefix = &quot;tree-sitter&quot;)]
fn init(_: &amp;Env) -&gt; Result&lt;()&gt; { Ok(()) }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><code>mod_in_name</code>: Whether to use Rust's <code>mod</code> path to construct <a href="./functions.html#naming">function names</a>. Default to <code>true</code>. For example, supposed that the crate is named <code>parser</code>, a <code>#[defun]</code> named <code>next_child</code> inside <code>mod cursor</code> will have the Lisp name of <code>parser-cursor-next-child</code>. This can also be overridden for each individual function, by an option of the same name on <code>#[defun]</code>.</p>
</li>
</ul>
<p><strong>Note</strong>: Often time, there's no initialization logic needed. A future version of this crate will support putting <code>#![emacs::module]</code> on the crate, without having to define a no-op function. See Rust's <a href="https://github.com/rust-lang/rust/issues/54726">issue #54726</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-functions"><a class="header" href="#writing-functions">Writing Functions</a></h1>
<p>You can use the attribute macro <code>#[defun]</code> to export Rust functions to the Lisp runtime, so that Lisp code can call them. The exporting process happens when the module is loaded, even if the definitions are inside another function that is never called, or inside a private <code>mod</code>.</p>
<h2 id="input-parameters"><a class="header" href="#input-parameters">Input Parameters</a></h2>
<p>Each parameter must be one of the following:</p>
<ul>
<li>An owned value of a type that implements <code>FromLisp</code>. This is for simple data types that have an equivalent in Lisp.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This docstring will appear in Lisp too!
#[defun]
fn inc(x: i64) -&gt; Result&lt;i64&gt; {
    Ok(x + 1)
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>A shared/mutable reference. This gives access to data structures that other module functions have created and embedded in the Lisp runtime (through <code>user-ptr</code> objects).
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[defun]
fn stash_pop(repo: &amp;mut git2::Repository) -&gt; Result&lt;()&gt; {
    repo.stash_pop(0, None)?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>A Lisp <code>Value</code>, or one of its &quot;sub-types&quot; (e.g. <code>Vector</code>). This allows holding off the conversion to Rust data structures until necessary, or working with values that don't have a meaningful representation in Rust, like Lisp lambdas.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[defun]
fn maybe_call(lambda: Value) -&gt; Result&lt;()&gt; {
    if some_hidden_native_logic() {
        lambda.call([])?;
    }
    Ok(())
}

#[defun(user_ptr)]
fn to_rust_vec_string(input: Vector) -&gt; Result&lt;Vec&lt;String&gt;&gt; {
    let mut vec = vec![];
    for e in input {
        vec.push(e.into_rust()?);
    }
    Ok(vec)
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>An <code>&amp;Env</code>. This enables interaction with the Lisp runtime. It does not appear in the function's Lisp signature. This is unnecessary if there is already another parameter with type <code>Value</code>, which allows accessing the runtime through <code>Value.env</code>.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Note that the function takes an owned `String`, not a reference, which would
// have been understood as a `user-ptr` object containing a Rust string.
#[defun]
fn hello(env: &amp;Env, name: String) -&gt; Result&lt;Value&lt;'_&gt;&gt; {
    env.message(format!(&quot;Hello, {}!&quot;, name))
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h2 id="return-value"><a class="header" href="#return-value">Return Value</a></h2>
<p>The return type must be <code>Result&lt;T&gt;</code>, where <code>T</code> is one of the following:</p>
<ul>
<li>A type that implements <code>IntoLisp</code>. This is for simple data types that have an equivalent in Lisp.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Return the path to the .git dir.
/// Return `nil' if the given path is not in a repo,
/// or if the .git path is not valid utf-8.
#[defun]
fn dot_git_path(path: String) -&gt; Result&lt;Option&lt;String&gt;&gt; {
    Ok(git2::Repository::discover(&amp;path).ok().and_then(|repo| {
        repo.path().to_str().map(|s| s.to_owned())
    }))
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>An arbitrary type. This allows embedding a native data structure in a <code>user-ptr</code> object, for read-write use cases. It requires <code>user_ptr</code> option to be specified. If the data is to be shared with background Rust threads, <code>user_ptr(rwlock)</code> or <code>user_ptr(mutex)</code> must be used instead.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[defun(user_ptr)]
fn repo(path: String) -&gt; Result&lt;git2::Repository&gt; {
    Ok(git2::Repository::discover(&amp;path)?)
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>A type that implements <code>Transfer</code>. This allows embedding a native data structure in a <code>user-ptr</code> object, for read-only use cases. It requires <code>user_ptr(direct)</code> option to be specified.</li>
<li><code>Value</code>, or one of its &quot;sub-types&quot; (e.g. <code>Vector</code>). This is mostly useful for returning an input parameter unchanged.</li>
</ul>
<p>See <a href="./custom-types.html">Custom Types</a> for more details on embedding Rust data structures in Lisp's <code>user-ptr</code> objects.</p>
<h2 id="naming"><a class="header" href="#naming">Naming</a></h2>
<p>By default, the function's Lisp name has the form <code>&lt;feature-prefix&gt;[mod-prefix]&lt;base-name&gt;</code>.</p>
<ul>
<li><code>feature-prefix</code> is the feature name followed by <code>-</code>. This can be customized by the <code>name</code>, <code>defun_prefix</code>, and <code>separator</code> <a href="./module.html#options">options</a> on <code>#[emacs::module]</code>.</li>
<li><code>mod-prefix</code> is constructed from the function's Rust <code>mod</code> path (with <code>_</code> and <code>::</code> replaced by <code>-</code>). This can be turned off crate-wide, or for individual function, using the option <code>mod_in_name</code>.</li>
<li><code>base-name</code> is the function's Rust name (with <code>_</code> replaced by <code>-</code>). This can be overridden with the option <code>name</code>.</li>
</ul>
<p>Examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Assuming crate's name is `native_parallelism`.

#[emacs::module(separator = &quot;/&quot;)]
fn init(_: &amp;Env) -&gt; Result&lt;()&gt; { Ok(()) }

mod shared_state {
    mod thread {
        // Ignore the nested mod's.
        // (native-parallelism/make-thread &quot;name&quot;)
        #[defun(mod_in_name = false)]
        fn make_thread(name: String) -&gt; Result&lt;Value&lt;'_&gt;&gt; {
            ..
        }
    }

    mod process {
        // (native-parallelism/shared-state-process-launch &quot;bckgrnd&quot;)
        #[defun]
        fn launch(name: String) -&gt; Result&lt;Value&lt;'_&gt;&gt; {
            ..
        }

        // Specify a name explicitly, since Rust identifier cannot contain `:`.
        // (native-parallelism/process:pool &quot;http-client&quot; 2 8)
        #[defun(mod_in_name = false, name = &quot;process:pool&quot;)]
        fn pool(name: String, min: i64, max: i64) -&gt; Result&lt;Value&lt;'_&gt;&gt; {
            ..
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p><code>#[defun]</code> converts Rust's docstring into Lisp's docstring. It also automatically constructs and appends the <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Function-Documentation.html#Function-Documentation">function's signature</a> to the end of the docstring, so that help modes can correctly display it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `(fn X Y)` is automatically appended, so you don't have to manually do so.
// In help modes, the signature will be (add X Y).

/// Add 2 numbers.
#[defun]
fn add(x: usize, y: usize) -&gt; Result&lt;usize&gt; {
    Ok(x + y)
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-lisp-functions"><a class="header" href="#calling-lisp-functions">Calling Lisp Functions</a></h1>
<p>Frequently-used Lisp functions are exposed as methods on <code>env</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>env.intern(&quot;defun&quot;)?;

env.message(&quot;Hello&quot;)?;

env.type_of(5.into_lisp(env)?)?;

env.provide(&quot;my-module&quot;)?;

env.list((1, &quot;str&quot;, true))?;
<span class="boring">}</span></code></pre></pre>
<p>To call arbitrary Lisp functions, use <code>env.call(func, args)</code>.</p>
<ul>
<li><code>func</code> can be:
<ul>
<li>A string identifying a named function in Lisp.</li>
<li>Any Lisp-callable <code>Value</code> (a symbol with a function assigned, a lambda, a subr). This can also be written as <code>func.call(args)</code>.</li>
</ul>
</li>
<li><code>args</code> can be:
<ul>
<li>An array, or a slice of <code>Value</code>.</li>
<li>A tuple of different types, each satisfying the <code>IntoLisp</code> trait.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// (list &quot;str&quot; 2)
env.call(&quot;list&quot;, (&quot;str&quot;, 2))?;
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let list = env.intern(&quot;list&quot;)?;
// (symbol-function 'list)
let subr = env.call(&quot;symbol-function&quot;, [list])?;
// (funcall 'list &quot;str&quot; 2)
env.call(list, (&quot;str&quot;, 2))?;
// (funcall (symbol-function 'list) &quot;str&quot; 2)
env.call(subr, (&quot;str&quot;, 2))?;
subr.call((&quot;str&quot;, 2))?; // Like the above, but shorter.
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// (add-hook 'text-mode-hook 'variable-pitch-mode)
env.call(&quot;add-hook&quot;, [
    env.intern(&quot;text-mode-hook&quot;)?,
    env.intern(&quot;variable-pitch-mode&quot;)?,
])?;
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[defun]
fn listify_vec(vector: Vector) -&gt; Result&lt;Value&gt; {
    let mut args = vec![];
    for e in vector {
        args.push(e)
    }
    vector.0.env.call(&quot;list&quot;, &amp;args)
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-conversions"><a class="header" href="#type-conversions">Type Conversions</a></h1>
<p>The type <code>Value</code> represents Lisp values:</p>
<ul>
<li>They can be copied around, but cannot outlive the <code>Env</code> they come from.</li>
<li>They are &quot;proxy values&quot;: only useful when converted to Rust values, or used as arguments when calling Lisp functions.</li>
</ul>
<h2 id="converting-a-lisp-value-to-rust"><a class="header" href="#converting-a-lisp-value-to-rust">Converting a Lisp <code>Value</code> to Rust</a></h2>
<p>This is enabled for types that implement <code>FromLisp</code>. Most built-in types are supported. Note that conversion may fail, so the return type is <code>Result&lt;T&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let i: i64 = value.into_rust()?; // error if Lisp value is not an integer
let f: f64 = value.into_rust()?; // error if Lisp value is nil

let s = value.into_rust::&lt;String&gt;()?;
let s: Option&lt;&amp;str&gt; = value.into_rust()?; // None if Lisp value is nil
<span class="boring">}</span></code></pre></pre>
<p>It's better to declare input types for <code>#[defun]</code> than calling <code>.into_rust()</code>, unless delayed conversion is needed.</p>
<h2 id="converting-a-rust-value-to-lisp"><a class="header" href="#converting-a-rust-value-to-lisp">Converting a Rust Value to Lisp</a></h2>
<p>This is enabled for types that implement <code>IntoLisp</code>. Most built-in types are supported. Note that conversion may fail, so the return type is <code>Result&lt;Value&lt;'_&gt;&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&quot;abc&quot;.into_lisp(env)?;
&quot;a\0bc&quot;.into_lisp(env)?; // NulError (Lisp string cannot contain null byte)

5.into_lisp(env)?;
65.3.into_lisp(env)?;

().into_lisp(env)?; // nil
true.into_lisp(env)?; // t
false.into_lisp(env)?; // nil
<span class="boring">}</span></code></pre></pre>
<p>It's better to declare return type for <code>#[defun]</code> than calling <code>.into_lisp(env)</code>, whenever possible.</p>
<h2 id="integers"><a class="header" href="#integers">Integers</a></h2>
<p>Integer conversion is lossless by default, which means that a module will signal an &quot;out of range&quot; <code>rust-error</code> in cases such as:</p>
<ul>
<li>A <code>#[defun]</code> expecting <code>u8</code> gets passed <code>-1</code>.</li>
<li>A <code>#[defun]</code> returning <code>u64</code> returns a value larger than <code>i64::max_value()</code>.</li>
</ul>
<p>To disable this behavior, use the <code>lossy-integer-conversion</code> feature:</p>
<pre><code class="language-toml">[dependencies.emacs]
features = [&quot;lossy-integer-conversion&quot;]
</code></pre>
<p>Support for Rust's <code>NonZero</code> integer types is disabled by default. To enable it, use the <code>nonzero-integer-conversion</code> feature:</p>
<pre><code class="language-toml">[dependencies.emacs]
features = [&quot;nonzero-integer-conversion&quot;]
</code></pre>
<h2 id="strings"><a class="header" href="#strings">Strings</a></h2>
<p>By default, no utf-8 validation is done when converting Lisp strings into Rust strings, because the string data returned by Emacs is guaranteed to be valid utf-8 sequence. If you think you've otherwise encountered an Emacs bug, utf-8 validation can be enabled through a feature:</p>
<pre><code class="language-toml">[dependencies.emacs]
features = [&quot;utf-8-validation&quot;]
</code></pre>
<h2 id="vectors"><a class="header" href="#vectors">Vectors</a></h2>
<p>Lisp vectors are represented by the type <code>Vector</code>, which can be considered a &quot;sub-type&quot; of <code>Value</code>.</p>
<p>To construct Lisp vectors, use <code>env.make_vector</code> and <code>env.vector</code>, which are efficient wrappers of Emacs's built-in subroutines <code>make-vector</code> and <code>vector</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>env.make_vector(5, ())?;

env.vector([1, 2, 3])?;

env.vector((1, &quot;x&quot;, true))?;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedding-rust-values-in-lisp"><a class="header" href="#embedding-rust-values-in-lisp">Embedding Rust Values in Lisp</a></h1>
<p>Speeding up Emacs is one of the goals of dynamic modules. Too many back-and-forth conversions between Rust's data structures and Lisp's can defeat the purpose. The solution to this is embedding Rust data structures in opaque <code>user-ptr</code> Lisp objects.</p>
<p>If a type implements <code>Transfer</code>, its heap-allocated (<code>Box</code>-wrapped) values can be moved into the Lisp runtime, where the GC will become its owner.</p>
<p>Lisp code sees these as opaque &quot;embedded user pointers&quot;, whose printed representation is something like <code>#&lt;user-ptr ptr=0x102e10b60 finalizer=0x103c9c390&gt;</code>. For these values to be useful, a Rust module needs to export additional functions to manipulate them.</p>
<p>Since these values are owned by the GC, Rust code can only safely access them through immutable references. Therefore, interior mutability is usually needed. As a result, <code>Transfer</code> is implemented for the smart pointer types <code>RefCell</code>, <code>Mutex</code>, <code>RwLock</code>, <code>Rc</code>, and <code>Arc</code>.</p>
<p>To return an embedded value, a function needs to be exported with a <code>user_ptr</code> option:</p>
<ul>
<li><code>user_ptr</code>: Embedding through a <code>RefCell</code>. This is suitable for common use cases, where module functions can borrow the underlying data back for read/write. It is safe because Lisp threads are subjected to the GIL. <code>BorrowError</code>/<code>BorrowMutError</code> may be signaled at runtime, depending on how module functions call back into the Lisp runtime.</li>
<li><code>user_ptr(rwlock)</code>, <code>user_ptr(mutex)</code>: Embedding through a <code>RwLock</code>/<code>Mutex</code>. This is suitable for sharing data between module functions (on Lisp threads, with <code>Env</code> access) and pure Rust code (on background threads, without access to an <code>Env</code>).</li>
<li><code>user_ptr(direct)</code>: Embedding a <code>Transfer</code> value directly. This is suitable for immutable data that will only be read back (not written to) by module functions (writing requires <code>unsafe</code> access, and is discouraged).</li>
</ul>
<p>As an example, a module that allows Emacs to use Rust's <code>HashMap</code> may look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use emacs::{defun, Env, Result, Value};

#[emacs::module(name = &quot;rs-hash-map&quot;, separator = &quot;/&quot;)]
fn init(env: &amp;Env) -&gt; Result&lt;()&gt; {
    type Map = HashMap&lt;String, String&gt;;

    #[defun(user_ptr)]
    fn make() -&gt; Result&lt;Map&gt; {
        Ok(Map::new())
    }

    #[defun]
    fn get(map: &amp;Map, key: String) -&gt; Result&lt;Option&lt;&amp;String&gt;&gt; {
        Ok(map.get(&amp;key))
    }

    #[defun]
    fn set(map: &amp;mut Map, key: String, value: String) -&gt; Result&lt;Option&lt;String&gt;&gt; {
        Ok(map.insert(key,value))
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-lisp">(let ((m (rs-hash-map/make)))
  (rs-hash-map/get m &quot;a&quot;)     ; -&gt; nil

  (rs-hash-map/set m &quot;a&quot; &quot;1&quot;) ; -&gt; nil
  (rs-hash-map/get m &quot;a&quot;)     ; -&gt; &quot;1&quot;

  (rs-hash-map/set m &quot;a&quot; &quot;2&quot;) ; -&gt; &quot;1&quot;
  (rs-hash-map/get m &quot;a&quot;))    ; -&gt; &quot;2&quot;
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li><code>Value.into_rust()</code> has a runtime type check, which fails with the error <code>'rust-wrong-type-user-ptr</code> if the value is a <code>user-ptr</code> object of a different type.</li>
<li>Input parameters with reference types are interpreted as <code>RefCell</code>-embedded <code>user-ptr</code> objects. For other kinds of embedding, you will have to use a <code>Value</code> parameter, and acquire the reference manually, since locking strategy (including deadlock avoidance/detection) should be module-specific.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::RwLock;

#[defun(user_ptr(rwlock))]
fn make() -&gt; Result&lt;Map&gt; {
    Ok(Map::new())
}

#[defun]
fn get(v: Value&lt;'_&gt;, key: String) -&gt; Result&lt;Value&lt;'_&gt;&gt; {
    let lock: &amp;RwLock&lt;Map&gt; = v.into_rust()?;
    let map = lock.try_read().map_err(|_| Error::msg(&quot;map is busy&quot;))?;
    map.get(&amp;key).into_lisp(v.env)
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h2 id="lifetime-constrained-types"><a class="header" href="#lifetime-constrained-types">Lifetime-constrained Types</a></h2>
<p>When a type is constrained by a (non-static) lifetime, its value cannot be embedded unchanged. Before embedding, the lifetime must be <strong>soundly</strong> elided. In other words, static ownership must be correctly given up.</p>
<p>The typical example is a struct holding a reference to another struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Tree;

pub struct Node&lt;'t&gt; {
    pub tree: &amp;'t Tree,
}

impl Tree {
    pub fn root_node(&amp;self) -&gt; Node&lt;'_&gt; {
        ...
    }
}

impl&lt;'t&gt; Node&lt;'t&gt; {
    pub fn child(&amp;self) -&gt; Node&lt;'t&gt; {
        ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this case, the lifetime can be elided by turning the static reference into a dynamic ref-counted pointer. The <a href="https://github.com/jpernst/rental">rental crate</a> provides a convenient way to do this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use]
extern crate rental;

use std::{rc::Rc, marker::PhantomData};
use emacs::{defun, Result};

// PhantomData is need because map_suffix requires a type parameter.
// See https://github.com/jpernst/rental/issues/35.
pub struct PhantomNode&lt;'t, T&gt;(Node&lt;'t&gt;, PhantomData&lt;T&gt;);

impl&lt;'t&gt; PhantomNode&lt;'t, ()&gt; {
    fn child(&amp;self) -&gt; Self {
        PhantomNode(self.0.child(), PhantomData)
    }
}

rental! {
    pub mod inner {
        use std::rc::Rc;

        // Self-referential struct that holds both
        // the actual Node and the ref-counted Tree.
        #[rental(map_suffix = &quot;T&quot;)]
        pub struct RentingNode&lt;T: 'static&gt; {
            tree: Rc&lt;super::Tree&gt;,
            node: super::PhantomNode&lt;'tree, T&gt;
        }
    }
}

type RentingNode = inner::RentingNode&lt;()&gt;;

#[defun(user_ptr)]
fn root_node(tree: Value) -&gt; Result&lt;RentingNode&gt; {
    let rc: &amp;Rc&lt;Tree&gt; = tree.into_rust()?;
    Ok(RentingNode::new(rc.clone(), |tree| tree.root_node()))
}

#[defun(user_ptr)]
fn child(node: &amp;RentingNode) -&gt; Result&lt;RentingNode&gt; {
    node.map(|n| n.child())
}
<span class="boring">}</span></code></pre></pre>
<p>Note that there's no <code>unsafe</code> involved directly, as the soundness proofs are already encapsulated in <code>rental</code> macros.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling-and-signaling"><a class="header" href="#error-handling-and-signaling">Error Handling and Signaling</a></h1>
<p>Emacs Lisp's <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Handling-Errors.html">error handling mechanism</a> uses <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Nonlocal-Exits.html">non-local exits</a>. Rust uses <code>Result</code> enum. <code>emacs-module-rs</code> converts between the 2 at the Rust-Lisp boundaries (more precisely, Rust-C).</p>
<p>The chosen error type is the <code>Error</code> struct from <a href="https://github.com/dtolnay/anyhow"><code>anyhow</code> crate</a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type Result&lt;T&gt; = result::Result&lt;T, anyhow::Error&gt;;
<span class="boring">}</span></code></pre></pre>
<h2 id="handling-lisp-errors-in-rust"><a class="header" href="#handling-lisp-errors-in-rust">Handling Lisp Errors in Rust</a></h2>
<p>When calling a Lisp function, it's usually a good idea to propagate signaled errors with the <code>?</code> operator, letting higher level (Lisp) code handle them. If you want to handle a specific error, you can use <code>error.downcast_ref</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match env.call(&quot;insert&quot;, &amp;[some_text]) {
    Err(error) =&gt; {
        // Handle `buffer-read-only` error.
        if let Some(Signal { symbol, .. }) = error.downcast_ref::&lt;ErrorKind&gt;() {
            let buffer_read_only = env.intern(&quot;buffer-read-only&quot;)?;
            // `symbol` is a `TempValue` that must be converted to `Value`.
            let symbol = unsafe { Ok(symbol.value(env)) };
            if env.eq(symbol, buffer_read_only) {
                env.message(&quot;This buffer is not writable!&quot;)?;
                return Ok(())
            }
        }
        // Propagate other errors.
        Err(error)
    },
    v =&gt; v,
}
<span class="boring">}</span></code></pre></pre>
<p>Note the use of <code>unsafe</code> to extract the error symbol as a <code>Value</code>. The reason is that, <code>ErrorKind::Signal</code> is marked <code>Send+Sync</code>, for compatibility with <code>anyhow</code>, while <code>Value</code> is lifetime-bound by <code>env</code>. The <code>unsafe</code> contract here requires the error being handled (and its <code>TempValue</code>) to come from this <code>env</code>, not from another thread, or from a global/thread-local storage.</p>
<h3 id="catching-values-thrown-by-lisp"><a class="header" href="#catching-values-thrown-by-lisp">Catching Values Thrown by Lisp</a></h3>
<p>This is similar to handling Lisp errors. The only difference is <code>ErrorKind::Throw</code> being used instead of <code>ErrorKind::Signal</code>.</p>
<h2 id="signaling-lisp-errors-from-rust"><a class="header" href="#signaling-lisp-errors-from-rust">Signaling Lisp Errors from Rust</a></h2>
<p>The function <code>env.signal</code> allows signaling a Lisp error from Rust code. The error symbol must have been defined, e.g. by the macro <code>define_errors!</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The parentheses denote parent error signals.
// If unspecified, the parent error signal is `error`.
emacs::define_errors! {
    my_custom_error &quot;This number should not be negative&quot; (arith_error range_error)
}

#[defun]
fn signal_if_negative(env: &amp;Env, x: i16) -&gt; Result&lt;()&gt; {
    if (x &lt; 0) {
        return env.signal(my_custom_error, (&quot;associated&quot;, &quot;DATA&quot;, 7))
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="handling-rust-errors-in-lisp"><a class="header" href="#handling-rust-errors-in-lisp">Handling Rust Errors in Lisp</a></h2>
<p>In addition to <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Standard-Errors.html">standard errors</a>, Rust module functions can signal Rust-specific errors, which can also be handled by <code>condition-case</code>:</p>
<ul>
<li><code>rust-error</code>: The message is <code>Rust error</code>. This covers all generic Rust-originated errors.</li>
<li><code>rust-wrong-type-user-ptr</code>: The message is <code>Wrong type user-ptr</code>. This happens when Rust code is passed a <code>user-ptr</code> of a type it's not expecting. It is a sub-type of <code>rust-error</code>.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// May signal if `value` holds a different type of hash map,
// or is a `user-ptr` defined in a non-Rust module.
let r: &amp;RefCell&lt;HashMap&lt;String, String&gt;&gt; = value.into_rust()?;
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h3 id="panics"><a class="header" href="#panics">Panics</a></h3>
<p>Unwinding from Rust into C is undefined behavior. <code>emacs-module-rs</code> prevents that by using <code>catch_unwind</code> at the Rust-to-C boundary to convert a panic into a Lisp's signal/throw of the appropriate type:</p>
<ul>
<li>Normally the panic is converted into a Lisp's error signal of the type <code>rust-panic</code>. Note that it is <strong>not a sub-type</strong> of <code>rust-error</code>.</li>
<li>If the panic value is an <code>ErrorKind</code>, it is converted to the corresponding signal/throw, as if a <code>Result</code> was returned. This allows propagating Lisp's non-local exits through contexts where <code>Result</code> is not appropriate, e.g. callbacks whose types are dictated by 3rd-party libraries, such as <code>tree-sitter</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>You can define tests using <a href="https://www.gnu.org/software/emacs/manual/html_node/ert/index.html">ert</a>, then use a bash script to load the module and run the tests. Examples:</p>
<ul>
<li>emacs-module-rs's own <a href="https://github.com/ubolonton/emacs-module-rs/blob/master/test-module/tests/main.el">tests</a> and <a href="https://github.com/ubolonton/emacs-module-rs/blob/master/bin/test">script</a>.</li>
<li>emacs-tree-sitter's <a href="https://github.com/ubolonton/emacs-tree-sitter/blob/master/tree-sitter-tests.el">tests</a> and <a href="https://github.com/ubolonton/emacs-tree-sitter/blob/master/bin/test">script</a>.</li>
</ul>
<p>For continuous testing during development, run this (requires <code>cargo-watch</code>):</p>
<pre><code class="language-bash">bin/test watch
</code></pre>
<p>A future version will have tighter integration with either <code>cargo</code> or <a href="https://github.com/cask/cask">Cask</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="live-reloading"><a class="header" href="#live-reloading">Live Reloading</a></h1>
<p>Live code reloading is very useful during development. However, Emacs does not support unloading modules. Live reloading thus requires a custom module loader, e.g. <a href="https://crates.io/crates/emacs-rs-module">emacs-rs-module</a>, which is itself a dynamic module.</p>
<p>To use it, load it in Emacs:</p>
<pre><code class="language-lisp">(require 'rs-module)
</code></pre>
<p>Then use it to load other modules instead of <code>require</code> or <code>module-load</code>:</p>
<pre><code class="language-lisp">;; Will unload the old version of the module first.
(rs-module/load &quot;full/path/to/module.so&quot;)
</code></pre>
<p><code>cargo</code> doesn't support installing dynamic libs yet, so you have to include <code>emacs-rs-module</code> as a dev dependency to compile it on your own:</p>
<pre><code class="language-toml">[dev-dependencies]
emacs-rs-module = { version = &quot;0.13.0&quot; }
</code></pre>
<p><a href="https://github.com/ubolonton/magit-libgit2#interactive-development">magit-libgit2</a> is an example of how to set this all up, to have live-reloading on-save.</p>
<p>A future version will have tighter integration with <code>cargo</code>.</p>
<p><strong>Notes</strong>:</p>
<ul>
<li>It mainly works on Linux, but potentially because Linux's dynamic loading system is unsafe (i.e. ridden with UB traps).</li>
<li>It doesn't work on macOS 10.13+ (High Sierra and up), because macOS doesn't unload dynamic libraries that use TLS (thread-local storage), for safety reason. See Rust's <a href="https://github.com/rust-lang/rust/issues/28794#issuecomment-368693049">issue #28794</a>.</li>
<li>It doesn't work on Windows, since loading the dll prevents writing to its file.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>


        <!-- Google Analytics Tag -->
        <script>
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-138609797-1', 'auto');
                ga('send', 'pageview');
            }
        </script>


        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="hljs-load-langs.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
