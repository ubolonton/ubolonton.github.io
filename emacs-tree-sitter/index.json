[
{
	"uri": "https://ubolonton.github.io/emacs-tree-sitter/",
	"title": "Tree-sitter",
	"tags": [],
	"description": "",
	"content": "tree-sitter is an Emacs binding for Tree-sitter, an incremental parsing system.\nIt aims to be the foundation for a new breed of Emacs packages that understand code structurally. For example:\n Faster, fine-grained code highlighting. More flexible code folding. Structural editing (like Paredit, or even better) for non-Lisp code. More informative indexing for imenu.  The author of Tree-sitter articulated its merits a lot better in this Strange Loop talk.\n"
},
{
	"uri": "https://ubolonton.github.io/emacs-tree-sitter/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": "tree-sitter requires Emacs 25.1 or above, built with dynamic module support. Some Emacs distributions have this disabled by default. To check whether your Emacs has dynamic module support enabled, try evaluating one of these:\n(functionp \u0026#39;module-load) ; should be t module-file-suffix ; should be non-nil  The methods below download pre-compiled binaries, so they only work for macOS, Linux and Windows, on x86_64 machines. For other systems, you will have to build from source.\n Installing from MELPA   Run M-x package-refresh-contents.\n  Install tree-sitter and tree-sitter-langs packages.\n  Load the framework and the language bundle:\n(require \u0026#39;tree-sitter) (require \u0026#39;tree-sitter-langs)   Installing with straight.el   Run (straight-pull-package \u0026quot;melpa\u0026quot;) to update MELPA recipes, if necessary.\n  Install tree-sitter and tree-sitter-langs packages.\n(straight-use-package \u0026#39;tree-sitter) (straight-use-package \u0026#39;tree-sitter-langs)   Load the framework and the language bundle:\n(require \u0026#39;tree-sitter) (require \u0026#39;tree-sitter-langs)   Installing from Source   Clone the source repository:\ngit clone https://github.com/ubolonton/emacs-tree-sitter   Add its core, lisp and langs directories to load-path:\n(add-to-list \u0026#39;load-path \u0026#34;/path-to/emacs-tree-sitter/core\u0026#34;) (add-to-list \u0026#39;load-path \u0026#34;/path-to/emacs-tree-sitter/lisp\u0026#34;) (add-to-list \u0026#39;load-path \u0026#34;/path-to/emacs-tree-sitter/langs\u0026#34;)   Load the libraries in your config:\n(require \u0026#39;tree-sitter) (require \u0026#39;tree-sitter-hl) (require \u0026#39;tree-sitter-langs) (require \u0026#39;tree-sitter-debug) (require \u0026#39;tree-sitter-query)   "
},
{
	"uri": "https://ubolonton.github.io/emacs-tree-sitter/getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": "The minor mode tree-sitter-mode provides a buffer-local syntax tree, which is kept up-to-date with changes to the buffer\u0026rsquo;s text.\nIt can be toggled in a buffer by the command tree-sitter-mode, or enabled through major mode hooks:\n(add-hook \u0026#39;rust-mode-hook #\u0026#39;tree-sitter-mode) To enable it for all supported major modes:\n(global-tree-sitter-mode) For the full list of supported major modes, check the variable tree-sitter-major-mode-language-alist.\nTurn on Syntax Highlighting Run M-x tree-sitter-hl-mode to replace the regex-based highlighting provided by font-lock-mode with tree-based syntax highlighting.\nFor more details, see Syntax Highlighting.\nView the Syntax Tree Run M-x tree-sitter-debug-mode to show the current buffer\u0026rsquo;s syntax tree in a separate buffer.\nPrinting the syntax tree can be slow for very large buffers, as it hasn\u0026rsquo;t been optimized yet.\n Play around with Tree Queries Run M-x tree-sitter-query-builder to open the query playground, where you can write tree queries and see matches highlighted in the source buffer.\nHere are some example queries to try:\n  Rust:\n(function_item (identifier) @func) (impl_item (type_identifier) @impl)   Python:\n(class_definition (identifier) @class) (function_definition (identifier) @func)   JavaScript:\n(function_declaration (identifier) @func) (variable_declarator (identifier) @var)   For more details on tree queries, see Queries.\n"
},
{
	"uri": "https://ubolonton.github.io/emacs-tree-sitter/languages/",
	"title": "Languages",
	"tags": [],
	"description": "",
	"content": "A language object defines how to parse a particular programming language. It is usually dynamically loaded from a shared library (.dylib, .so, .dll).\nThe variable tree-sitter-load-path is a list of directories that the function tree-sitter-require uses to search for these shared libraries. This is similar to how the built-in function require searches for Emacs libraries on load-path. The default value contains the directory used by the tree-sitter CLI tool.\n;; Load the language definition for Rust, if it hasn\u0026#39;t been loaded. ;; Return the language object. (tree-sitter-require \u0026#39;rust) The package tree-sitter-langs is a language bundle that contains shared libraries for some languages (as well as syntax highlighting queries). When it is loaded, its shared libraries are prioritized over the CLI\u0026rsquo;s directory.\nCurrently, there are no language major modes built on top of tree-sitter. Instead, syntax-aware functionalities are provided by tree-sitter-mode and its dependent minor modes. They determine the language object to use by consulting the variable tree-sitter-major-mode-language-alist. This list is empty by default, and gets populated by tree-sitter-langs when it is loaded.\n\u0026#39;((agda-mode . agda) (sh-mode . bash) (c-mode . c) (csharp-mode . c-sharp) (c++-mode . cpp) (css-mode . css) (elm-mode . elm) (go-mode . go) (haskell-mode . haskell) (html-mode . html) (java-mode . java) (js-mode . javascript) (js2-mode . javascript) (json-mode . json) (jsonc-mode . json) (julia-mode . julia) (ocaml-mode . ocaml) (php-mode . php) (python-mode . python) (rjsx-mode . javascript) (ruby-mode . ruby) (rust-mode . rust) (rustic-mode . rust) (scala-mode . scala) (swift-mode . swift) (tuareg-mode . ocaml) (typescript-mode . typescript)) "
},
{
	"uri": "https://ubolonton.github.io/emacs-tree-sitter/syntax-highlighting/",
	"title": "Syntax Highlighting",
	"tags": [],
	"description": "",
	"content": "Syntax highlighting is provided by the minor mode tree-sitter-hl-mode. It overrides the regex-based highlighting provided by font-lock-mode, using the syntax tree provided by tree-sitter-mode. It is based on tree queries, a system for pattern-matching on Tree-sitter\u0026rsquo;s syntax trees.\nIt can be toggled in a buffer by the command tree-sitter-hl-mode, or enabled through major mode hooks:\n(add-hook \u0026#39;rust-mode-hook #\u0026#39;tree-sitter-hl-mode) To enable it whenever possible (assuming the language major modes were already installed):\n(global-tree-sitter-mode) (add-hook \u0026#39;tree-sitter-after-on-hook #\u0026#39;tree-sitter-hl-mode) The package tree-sitter-langs provides syntax highlighting queries for some languages:\n C C++ CSS Go HTML Java JavaScript PHP Python Ruby Rust TypeScript  Most of the highlighting queries in the bundle are very basic, as they are copies of those included in the grammar repositories. Queries for languages written in bold have received additional work to leverage more of the querying system\u0026rsquo;s expressiveness.\nContributions to highlighting queries are welcome.\n "
},
{
	"uri": "https://ubolonton.github.io/emacs-tree-sitter/syntax-highlighting/queries/",
	"title": "Queries",
	"tags": [],
	"description": "",
	"content": "A query is a set of patterns, written in a Lisp-like syntax.\nQueries are language-specific. Different language grammars use different node types and field names. Examples in this section apply to Rust.\n Patterns A pattern is an S-expression (Lisp form), optionally preceded by a field name, suffixed with a quantifier, and/or followed by a capture name.\nA node form is a list form whose first element is a symbol (except for the special symbols, described later). The symbol specifies the type of node to match, while the remaining elements describe what the inner structure of a matched node (i.e. its child nodes) should look like.\n;; Match any function call. (call_expression) ;; Match any function call where at least one arg is an identifier. (call_expression (arguments (identifier))) A string literal denotes an anonymous node.\n;; Match the operator `==\u0026#39; . \u0026#34;==\u0026#34; Captures and Fields Captures allow associating names with specific nodes in a pattern. A symbol starting with the character @ denotes a capture name. It is written after the pattern it refers to. When used for syntax highlighting, capture names are then mapped to display faces, which determine the appearance of the corresponding nodes.\n;; Match function calls. For each match, the function name is captured ;; under the name `function.call\u0026#39;, and the argument list is associated ;; with the name `function.args\u0026#39;. (call_expression (identifier) @function.call (arguments) @function.args) Certain node types assign unique field names to specific child nodes. Within a pattern, a field name is denoted by a symbol ending with the character :, written before the child pattern it refers to.\n;; Using field names, for clarity. (call_expression function: (identifier) @function.call arguments: (arguments) @function.args) Groups and Predicates A group form is a list form whose first element is a node form. It is used to denote a sequence of sibling nodes, and to group predicate forms with node forms.\n;; Match a comment followed by a function declaration. ((line_comment) (function_item)) A predicate form can appear anywhere in a group form. It is a list form whose first element is a symbol starting with the character .. Each remaining element is either a capture name, or a string literal.\n;; Match identifiers written in SCREAMING_SNAKE_CASE. ((identifier) @constant (.match? @constant \u0026#34;^[A-Z][A-Z_\\\\d]+\u0026#34;)) Currently, the supported predicates for syntax highlighting are .match?, .not-match?, .eq? and .not-eq?.\nAlternations An alternation form is a vector of patterns. It denotes a pattern that matches a node when any of the alternative patterns matches.\n[(self) (super) (crate) (mutable_specifier)] @keyword [\u0026#34;==\u0026#34; \u0026#34;!=\u0026#34; \u0026#34;\u0026lt;\u0026#34; \u0026#34;\u0026lt;=\u0026#34; \u0026#34;\u0026gt;\u0026#34; \u0026#34;\u0026gt;=\u0026#34;] @operator (call_expression function: [(identifier) @function.call (field_expression field: (field_identifier) @method.call)]) Repetitions and Wildcards A form can be suffixed by one of the quantification operators: at-most-once ?, at-least-once +, zero-or-more *.\n;; Match any function call. Capture a string arg, if any. (call_expression function: (identifier) @function.call arguments: (arguments (string_literal)? @the-string-arg)) The special wildcard symbol _ matches any node (except for anonymous nodes).\n;; Leaving out child nodes\u0026#39; types, for brevity. (call_expression function: (_) @function.call arguments: (_) @function.args) For more details, see Tree-sitter\u0026rsquo;s documentation:\n https://tree-sitter.github.io/tree-sitter/using-parsers#pattern-matching-with-queries https://tree-sitter.github.io/tree-sitter/syntax-highlighting#queries  "
},
{
	"uri": "https://ubolonton.github.io/emacs-tree-sitter/syntax-highlighting/customization/",
	"title": "Customization",
	"tags": [],
	"description": "",
	"content": "Theming tree-sitter-hl-mode provides a richer set of faces than font-lock-mode. For example, function definitions are highlighted with tree-sitter-hl-face:function, while function calls are highlighted with tree-sitter-hl-face:function.call. However, for compatibility with existing themes, the default values for most of these faces inherit from built-in font-lock faces.\nIf you want to leverage the full power of Tree-sitter\u0026rsquo;s syntax highlighting approach, you should customize these faces.\nFace Mappings By default, when the highlighting query associates a node with CAPTURE-NAME, it will be highlighted with the face tree-sitter-hl-face:CAPTURE-NAME. This behavior can be changed by customizing the variable tree-sitter-hl-face-mapping-function.\n;; Don\u0026#39;t highlight strings, in any language. (add-function :before-while tree-sitter-hl-face-mapping-function (lambda (capture-name) (not (string= capture-name \u0026#34;string\u0026#34;)))) ;; Highlight only keywords in Python. (add-hook \u0026#39;python-mode-hook (lambda () (add-function :before-while (local \u0026#39;tree-sitter-hl-face-mapping-function) (lambda (capture-name) (string= capture-name \u0026#34;keyword\u0026#34;))))) ;; Highlight Python docstrings with a different face. (add-hook \u0026#39;python-mode-hook (lambda () (add-function :before-until (local \u0026#39;tree-sitter-hl-face-mapping-function) (lambda (capture-name) (pcase capture-name (\u0026#34;doc\u0026#34; \u0026#39;font-lock-comment-face)))))) Additional Patterns You can use the function tree-sitter-hl-add-patterns to add custom highlighting patterns for a specific language, or in a buffer. These patterns will be prioritized over patterns defined by major modes or language bundles (tree-sitter-hl-default-patterns). Below are some examples:\nLanguage-specific patterns:\n;; Highlight Python\u0026#39;s single-quoted strings as constants. (tree-sitter-hl-add-patterns \u0026#39;python [((string) @constant (.match? @constant \u0026#34;^\u0026#39;\u0026#34;))]) Buffer-local patterns:\n;; Map @rust.unsafe.use capture to a custom face. (add-function :before-until tree-sitter-hl-face-mapping-function (lambda (capture-name) (pcase capture-name (\u0026#34;rust.unsafe.use\u0026#34; \u0026#39;my-dangerous-code-pattern-face)))) ;; Add highlighting patterns for @rust.unsafe.use. (add-hook \u0026#39;rust-mode-hook (lambda () (tree-sitter-hl-add-patterns nil [(unsafe_block) @rust.unsafe.use (impl_item \u0026#34;unsafe\u0026#34;) @rust.unsafe.use]))) Project-specific patterns (through .dir-locals.el):\n;; Highlight DEFUN macros (in Emacs\u0026#39;s C source). ((c-mode . ((tree-sitter-hl--extra-patterns-list [((call_expression function: (identifier) @keyword arguments: (argument_list (string_literal) @function)) (.eq? @keyword \u0026#34;DEFUN\u0026#34;))]))))  When a node matches multiple patterns in a highlighting query, earlier patterns are prioritized.\n;; More specific patterns should be written earlier. ((lifetime (identifier) @type.builtin) (.eq? @type.builtin \u0026#34;static\u0026#34;)) (lifetime (identifier) @label) \n "
},
{
	"uri": "https://ubolonton.github.io/emacs-tree-sitter/syntax-highlighting/interface-for-modes/",
	"title": "Interface for Modes",
	"tags": [],
	"description": "",
	"content": "Major modes that want to integrate with tree-sitter-hl-mode should set the variable tree-sitter-hl-default-patterns. It plays a similar role to font-lock-defaults.\nMinor modes that want to customize syntax highlighting should call the function tree-sitter-hl-add-patterns. It plays a similar role to font-lock-add-keywords.\nThe language bundle tree-sitter-langs provides highlighting queries for several languages. These queries will be used when the corresponding major modes do not set tree-sitter-hl-default-patterns.\n "
},
{
	"uri": "https://ubolonton.github.io/emacs-tree-sitter/api/",
	"title": "Core APIs",
	"tags": [],
	"description": "",
	"content": "Emacs Tree-sitter is split into 2 packages:\n tree-sitter: The high-level features, i.e. the framework and the apps. For example, Syntax Highlighting. tsc: The core functionalities, i.e. the lib, which is the focus of this section.  In older versions, the core APIs were prefixed with ts-, and provided by tree-sitter-core.el. They are still available as deprecated aliases, but will eventually be removed.\nThis was changed to conform with MELPA\u0026rsquo;s conventions and to avoid naming conflicts with ts.el.\n Tree-sitter\u0026rsquo;s own documentation is a good read to understand its concepts and features. This documentation focuses more on details that are specific to Emacs Lisp.\nIn order to follow Emacs Lisp\u0026rsquo;s conventions, functions and data types in this package may differ from those in Tree-sitter\u0026rsquo;s C/Rust APIs. These differences are discussed in their corresponding sections.\nData Types  language: A language object that defines how to parse a language. parser: A stateful object that consumes source code and produces a parse tree. tree: A parse tree that contains syntax node's, which can be inspected. cursor: A stateful object used to traverse a parse tree. query: A compiled list of structural patterns to search for in a parse tree. query-cursor A stateful object used to execute a query. point: A pair of (line-number . byte-column).  line-number is the absolute line number returned by line-number-at-pos, counting from 1. byte-column counts from 0, like current-column. However, unlike that function, it counts bytes, instead of displayed glyphs.   range: A vector in the form of [start-bytepos end-bytepos start-point end-point].  These types are understood only by this package and its type-checking predicates, which are useful for debugging: tsc-language-p, tsc-tree-p, tsc-node-p\u0026hellip; They are not recognized by type-of.\n For consistency with Emacs\u0026rsquo;s conventions, there are some differences compared to Tree-sitter\u0026rsquo;s C/Rust APIs:\n It uses 1-based byte positions, instead of 0-based byte offsets. It uses 1-based line numbers, instead of 0-based row coordinates. Node types are symbols (named nodes) and strings (anonymous nodes), instead of always being strings. Field names are keywords, instead of strings.  "
},
{
	"uri": "https://ubolonton.github.io/emacs-tree-sitter/api/parsing/",
	"title": "Parsing",
	"tags": [],
	"description": "",
	"content": " The minor mode tree-sitter-mode provides the high-level interface for working with an up-to-date buffer-local syntax tree. Writing a Dependent Minor Mode is recommended over directly using the low level parsing APIs below.\n Parsing is done through stateful parser objects.\n tsc-make-parser Create a new parser without setting a language. tsc-set-language parser language Set a parser\u0026rsquo;s active language. tsc-parse-string parser string Parse a single string of source code. This is useful for quick, one-off parsing needs. (let ((parser (tsc-make-parser))) (tsc-set-language parser (tree-sitter-require \u0026#39;rust)) (tsc-parse-string parser \u0026#34;fn foo() {}\u0026#34;))  tsc-parse-chunks parser input-function old-tree Parse chunks of source code generated by an input-function. The function should take 3 parameters: (bytepos line-number byte-column), and return a fragment of the source code, starting from the position identified by either bytepos or (line-number . byte-column). It should return an empty string to signal the end of the source code. Incremental parsing: If you have already parsed an earlier version of this document, and it has since been edited, pass the previously parsed old-tree so that its unchanged parts can be reused. This will save time and memory. For this to work correctly, you must have already edited it using tsc-edit-tree function in a way that exactly matches the source code changes.\n tsc-edit-tree tree ... Prepare a tree for incremental parsing, by editing it to keep it in sync with source code that has been edited. You must describe the edit both in terms of byte positions and in terms of (line-number . byte-column) coordinates.  For more details, see Tree-sitter\u0026rsquo;s documentation:\n https://tree-sitter.github.io/tree-sitter/using-parsers#basic-parsing https://tree-sitter.github.io/tree-sitter/using-parsers#advanced-parsing  "
},
{
	"uri": "https://ubolonton.github.io/emacs-tree-sitter/api/inspecting/",
	"title": "Inspecting",
	"tags": [],
	"description": "",
	"content": "The result of parsing is a syntax tree of the entire source code (string, buffer). It contains syntax nodes that indicate the structure of the source code. Tree-sitter provides APIs to inspect and traverse this structure, but does not support modifying it directly (for the purposes of source code transformation or generation).\n tsc-root-node tree Get the root node of a syntax tree. tsc-changed-ranges old-tree new-tree Compare an edited old syntax tree to a newly parsed one. It is typically used in tree-sitter-after-change-functions hook. This function returns a sequence of ranges whose syntactic structure has changed. Each range is a vector in the form of [start-bytepos end-bytepos start-point end-point]. In tree-sitter's context, point typically means a pair of (line-number . byte-column), instead of its usual meaning of current position. See Data Types.\n  tsc-tree-to-sexp  tsc-node-to-sexp Debug utilities that return the sexp representation of a syntax tree/node, as a string.  Node Properties Functions that return a node\u0026rsquo;s property have the prefix tsc-node-:\n tsc-node-type  tsc-node-named-p Tree-sitter\u0026rsquo;s parse tree is a concrete syntax tree, which contains nodes for every single token in the source code, including things which are typically omitted in a simpler abstract syntax tree, like commas, parentheses, punctuations, keywords. These less important nodes are called anonymous nodes. Their node types are strings. For example: \u0026quot;if\u0026quot;, \u0026quot;else\u0026quot;. The more important nodes are call named nodes. Their node types are symbols, corresponding to the named rules that define them in the language\u0026rsquo;s grammar. For example: identifier, block, if_expression.\nIn Tree-sitter\u0026rsquo;s documentation, due to the low-level nature of C and JSON, node types are always represented as strings. Representing named node types as symbols makes it more Lisp-idiomatic, and is more consistent with tree queries.\n  tsc-node-extra-p Whether a node is an extra node, which is not required by the grammar, but can appear anywhere in the source code, like comments. tsc-node-error-p Whether the node represents a syntax error. The node type of an error node is the special symbol ERROR. tsc-node-has-error-p Whether the node contains a syntax error. tsc-node-missing-p Whether a node is a missing node, i.e. inserted by the parser in order to recover from certain kinds of syntax errors, like a missing semicolon. tsc-node-start-byte  tsc-node-end-byte The start/end byte position of a node. tsc-node-start-position  tsc-node-end-position The start/end position of a node. These functions assume that the current buffer is the source buffer of the given node\u0026rsquo;s syntax tree. tsc-node-range A node\u0026rsquo;s [start-bytepos end-bytepos start-point end-point].  Related Nodes As described in the previous section, the -named- variants of the functions in this section allow working on the parse tree as if it is an abstract syntax tree.\n tsc-get-parent node Get a node\u0026rsquo;s parent node. tsc-count-children node  tsc-count-named-children node Count the number of child nodes (all, or named only). tsc-get-nth-child node nth  tsc-get-nth-named-child node nth Get a child node by its 0-based index (any, or named only). (let ((func (tree-sitter-node-at-point \u0026#39;function_item))) (tsc-get-nth-child func 0) ; An \u0026#34;fn\u0026#34; node (tsc-get-nth-named-child func 0)) ; An \u0026#39;identifier node  tsc-get-child-by-field node field Certain node types assign unique field names to specific child nodes. This function allows retrieving child nodes by their field names, instead of by their indexes. The field name should be specified as a keyword. ;; Get name of the current function definition. (let ((func (tree-sitter-node-at-point \u0026#39;function_item))) (tsc-node-text (tsc-get-child-by-field func :name)))  In Tree-sitter\u0026rsquo;s documentation, due to the low-level nature of C and JSON, field names are specified as strings. Representing field names as keywords makes it more Lisp-idiomatic.\n  tsc-get-next-sibling node  tsc-get-prev-sibling node  tsc-get-next-named-sibling node  tsc-get-prev-named-sibling node Get next/previous sibling node (any, or named only). tsc-get-descendant-for-position-range node beg end  tsc-get-named-descendant-for-position-range node beg end Get smallest descendant node that spans the given range. ;; Get the syntax node the cursor is on. (let ((p (point))) (tsc-get-descendant-for-position-range (tsc-root-node tree-sitter-tree) p p))   "
},
{
	"uri": "https://ubolonton.github.io/emacs-tree-sitter/api/walking/",
	"title": "Walking",
	"tags": [],
	"description": "",
	"content": "Tree-walking functions enable efficient traversal of the syntax tree with the help of a stateful cursor object.\n tsc-make-cursor node-or-tree Create a new cursor on a node. The cursor cannot move out of this node. If called on a tree, the cursor is created on the tree\u0026rsquo;s root node. tsc-goto-parent cursor  tsc-goto-first-child cursor  tsc-goto-next-sibling cursor Attempt to move the cursor to the parent node, the first child node, or the next sibling node. This function returns t if the move was successful, nil if the move is invalid. tsc-goto-first-child-for-position cursor pos Attempt to move the cursor to the first child node that extends beyond the given position. This function returns the index of the child node found, nil otherwise. tsc-reset-cursor cursor node Re-initialize the cursor to start on a different node. tsc-current-node cursor Get the node that the cursor is currently on. tsc-current-field cursor Get the field name (as a keyword) associated with the current node.  "
},
{
	"uri": "https://ubolonton.github.io/emacs-tree-sitter/api/querying/",
	"title": "Querying",
	"tags": [],
	"description": "",
	"content": "Tree-sitter provides a Lisp-like query language to search for patterns in the syntax tree.\n tsc-make-query language patterns [tag-assigner] Create a new query for the given language. This query cannot be run on syntax nodes of other languages. Patterns can be specified as either a sequence (usually a vector, for convenience) of S-expressions, or their textual representations, concatenated into a string.\nWhen the query is executed, each captured node is tagged with a symbol, whose name is the corresponding capture name defined in patterns. For example, nodes that are captured as @function.builtin will be tagged with the symbol function.builtin. This behavior can be customized by the optional function tag-assigner, which should return a tag value when given a capture name (without the prefix @). If it returns nil, the associated capture name is disabled.\n tsc-make-query-cursor Create a new query cursor to execute queries. It stores the state that is needed to iteratively search for matches. tsc-query-captures query node text-function [query-cursor]  tsc-query-matches query node text-function [query-cursor] Execute a query on the given syntax node. tsc-query-captures returns a sequence of captures, sorted in the order they appear in the source code. tsc-query-matches returns a sequence of matches, sorted in the order they were found. Each capture has the form (capture-tag . captured-node), where capture-tag is a symbol, whose name is the corresponding capture name defined in query (without the prefix @). If query was created with a custom tag assigner, capture-tag is instead the value returned by that function.\nEach match has the form (pattern-index . match-captures), where pattern-index is the 0-based position of the matched pattern within query, and match-captures is a sequence of captures associated with the match.\nSince the syntax tree doesn\u0026rsquo;t store the source code\u0026rsquo;s text, text-function is called to get nodes\u0026rsquo; texts (for text-based predicates). It should take 2 parameters: (beg-byte end-byte), and return the corresponding chunk of text in the source code. Usually this should be #'ts--buffer-substring-no-properties.\nFor performance reason, query-cursor should typically be created once, and reused between query executions. It should be omitted only for one-off experimentation.\n  "
},
{
	"uri": "https://ubolonton.github.io/emacs-tree-sitter/tree-sitter-mode/",
	"title": "Tree-sitter Minor Mode",
	"tags": [],
	"description": "",
	"content": "tree-sitter-mode is a minor mode that provides a buffer-local up-to-date syntax tree.\nTODO: Write this.\n Hook: tree-sitter-after-on-hook  Hook: tree-sitter-after-first-parse-hook  Hook: tree-sitter-after-change-functions  Variable: tree-sitter-major-mode-language-alist  Variable: tree-sitter-language  Variable: tree-sitter-tree  Function: tree-sitter-node-at-point [node-type]   Writing a Dependent Minor Mode See the docstring of tree-sitter--handle-dependent.\n"
},
{
	"uri": "https://ubolonton.github.io/emacs-tree-sitter/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ubolonton.github.io/emacs-tree-sitter/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]